{"template":"__react_static_root__/src/pages/samples.tsx","sharedHashesByProp":{},"data":{"samples":[{"name":"layout","title":"Layout","description":"UI Layout Examples","code":"\r\n\r\n# Layout demo\r\n### Move the slider!\r\n\r\nelevation_slider: ui.slider {\r\n  min: 1\r\n  max: 16\r\n  value: 4\r\n  label: \"Elevation\"\r\n}\r\n\r\nsize_slider: ui.slider {\r\n  min: 0\r\n  max: 4\r\n  step: 0.1\r\n  label: \"Size Variation\"\r\n}\r\n\r\ndemo: ui.surface {\r\n  direction: \"column\"\r\n  item0: ui.surface {\r\n    color: \"primary\"\r\n    elevation: elevation_slider.value\r\n    item0: ui.textbox {\r\n      text: str(elevation)\r\n    }\r\n  }\r\n  item1: ui.surface {\r\n    flex: size_slider.value\r\n    elevation: 0 - elevation_slider.value\r\n    color: \"secondary\"\r\n    item0: ui.textbox {\r\n      text: str(elevation)\r\n    }\r\n  }\r\n  item2: ui.surface {\r\n    elevation: elevation_slider.value\r\n    item0: ui.outline {}\r\n  }\r\n}\r\n\r\nui: ui {\r\n  page: ui.surface {\r\n    direction: \"row\"\r\n    responsive: true\r\n    item0: ui.surface {\r\n      direction: \"column\"\r\n      elevation: 16\r\n      item0: ui.outline {}\r\n      item1: ui.surface {\r\n        direction: \"column\"\r\n        flex: 0\r\n        item0: elevation_slider\r\n        item1: size_slider\r\n      }\r\n    }\r\n    item1: demo\r\n  }\r\n}\r\n\r\n##> Fading panels\r\nfading_panel: ui.surface {\r\n  fade: true\r\n  item0: ui.textbox {\r\n    text: str(elevation)\r\n  }\r\n}\r\n\r\ndemo: ui.surface {\r\n  direction: \"column\"\r\n  \r\n  item0: fading_panel {\r\n    flex: size_slider.value\r\n    color: \"primary\"\r\n    elevation: 0 - elevation_slider.value\r\n  }\r\n  item1: fading_panel {\r\n    color: \"secondary\"\r\n    elevation: elevation_slider.value\r\n  }\r\n  item2: fading_panel {\r\n    flex: 4 - size_slider.value\r\n    color: \"background\"\r\n    elevation: 0 - elevation_slider.value\r\n  }\r\n  item3: fading_panel {\r\n    color: \"secondary\"\r\n    elevation: elevation_slider.value\r\n  }\r\n}\r\n\r\n##> Flat style\r\nui: ui {\r\n  page: page {\r\n    item0: item0 {\r\n      elevation: 0\r\n      fade: true\r\n    }\r\n  }\r\n}\r\n\r\ndemo: ui.surface {\r\n  direction: \"column\"\r\n  color: \"secondary\"\r\n  fade: true\r\n  item0: ui.surface {}\r\n  item1: ui.surface {\r\n    color: \"background\"\r\n    item0: ui.surface {\r\n      flex: (size_slider.value + 1) / 4\r\n      color: \"primary\"\r\n    }\r\n    item1: ui.surface {\r\n      direction: \"column\"\r\n      item0: ui.surface {\r\n        color: \"background\"\r\n      }\r\n      item1: ui.surface {\r\n        flex: size_slider.value\r\n        color: \"secondary\"\r\n      }\r\n      item2: ui.surface {\r\n        flex: 4 - size_slider.value\r\n        color: \"background\"\r\n      }\r\n      item3: ui.surface {\r\n        flex: size_slider.value * 2\r\n        color: \"secondary\"\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n##> Dark mode\r\nui: ui {\r\n  theme: default_themes.dark\r\n}\r\n\r\n###> Elevation light\r\nelevation_slider: elevation_slider {\r\n  value: 1\r\n}\r\n\r\nelevation_panel: fading_panel {\r\n  fade: false\r\n}\r\n\r\ndemo: ui.surface {\r\n  direction: \"column\"\r\n  fade: true\r\n  item0: ui.surface {\r\n    direction: \"column\"\r\n    item0: elevation_panel {\r\n      flex: size_slider.value\r\n      color: \"background\"\r\n      elevation: elevation_slider.value - 8\r\n    }\r\n    item1: elevation_panel {\r\n      color: \"background\"\r\n      elevation: elevation_slider.value - 4\r\n    }\r\n    item2: elevation_panel {\r\n      flex: 4 - size_slider.value\r\n      color: \"background\"\r\n      elevation: elevation_slider.value\r\n    }\r\n    item3: elevation_panel {\r\n      color: \"background\"\r\n      elevation: min(elevation_slider.value + 4, 16)\r\n    }\r\n  }\r\n}\r\n"},{"name":"plots","title":"Plots","description":"Graph toolkit","code":"\r\n\r\n\r\nui: ui {\r\n  theme: default_themes.dark\r\n}\r\n\r\n# Plot Demo\r\n\r\nf: x => sin(x * sin(time)) * 0.4 - 2\r\n\r\neps: 0.01\r\nderive: func => x => (func(x + eps) - func(x - eps)) / (2 * eps)\r\n\r\ng: derive(f)\r\n\r\ndemo_plot: plot.view {\r\n  viewport: viewport {\r\n    center: vec2(sin(time), sin(time * 0.7))\r\n    size: vec2(8, 8)\r\n  }\r\n  item0: plot.grid {}\r\n  item1: plot.polygon {\r\n    point0: point0 + vec2(sin(time), 0)\r\n    point2: point2 + vec2(0, sin(time * 0.4))\r\n    point3: point2 + vec2(1, sin(time * 0.4))\r\n  }\r\n  item2: item1 {\r\n    color: ui.theme.colors.secondary\r\n    point1: point1 + vec2(0.5, 2.0)\r\n    point3: point3 - vec2(1, sin(time * 0.4))\r\n  }\r\n  item3: plot.angle {\r\n    point0: vec2(2.4 + cos(time), 2.2 + sin(time))\r\n    point1: vec2(2.4, 2.2)\r\n    point2: vec2(4.0, 2.4)\r\n    label: \"α\"\r\n  }\r\n  item4: plot.angle {\r\n    color: vec3(0.4, 0.8, 0.5)\r\n    point0: vec2(1.4 + cos(time * 0.2), 1 + sin(time * 0.72))\r\n    point1: vec2(1.4, 1)\r\n    point2: vec2(1.2, 0.2)\r\n    label: \"β\"\r\n  }\r\n  item5: plot.function {\r\n    function: f\r\n  }\r\n  item6: plot.point {\r\n    position: vec2(-2, item5.function(-2))\r\n    guides: true\r\n    label: \"f(-2)\"\r\n  }\r\n  item7: plot.function {\r\n    function: derive(item5.function)\r\n    color: vec3(0.4, 0.6, 0.8)\r\n  }\r\n  # item7: plot.circle {\r\n  #   color: item4.color\r\n  #   center: vec2(3, -2)\r\n  #   slice: slice * sin(time * 0.3) * 0.5 + slice * 0.5\r\n  # }\r\n  # item7: plot.vector {\r\n  #   color: vec3(0.4, 0.8, 0.9)\r\n  #   start: vec2(-4, 1)\r\n  #   end: start + vec2(cos(time), sin(time))\r\n  #   label: \"u\"\r\n  # }\r\n}\r\n\r\nui: ui {\r\n  page: ui.surface {\r\n    color: \"primary\"\r\n    direction: \"column\"\r\n    item0: ui.surface {\r\n      flex: 0\r\n      item0: ui.outline\r\n    }\r\n    item1: ui.surface {\r\n      color: \"background\"\r\n      elevation: -2\r\n      item0: demo_plot\r\n    }\r\n  }\r\n}\r\n\r\n#>\r\n\r\ndemo_plot: demo_plot {\r\n  viewport: viewport {\r\n    center: animate(center, center + vec2(4, 0), 0.5)\r\n    size: animate(size, size * 2, 0.5)\r\n  }\r\n\r\n  # item7: item7 {\r\n  #   start: animate(start, start + vec2(15, 0), 0.5)\r\n  # }\r\n\r\n  item5: item5 {\r\n    function: x => animate(f(x), x * x, 0.5)\r\n  }\r\n}\r\n"},{"name":"shaders","title":"Shaders","description":"GLSL shaders embedding","code":"\r\n\r\n\r\n# Shader demo\r\n\r\nshader_panel: ui.surface {\r\n  shader: ui.shader {}\r\n  controls: ui.surface {\r\n  }\r\n\r\n  direction: \"column\"\r\n  color: \"background\"\r\n  elevation: 2\r\n  fade: true\r\n  item0: shader\r\n  item1: ui.surface {\r\n    flex: 0\r\n    item0: controls\r\n  }\r\n}\r\n\r\nleft_panel: shader_panel {\r\n  speed_slider: ui.slider {\r\n    label: \"Speed\"\r\n    min: 1\r\n    max: 10\r\n    step: 0.01\r\n    value: 1\r\n  }\r\n\r\n  power_slider: ui.slider {\r\n    label: \"Power\"\r\n    min: 0.2\r\n    max: 1\r\n    step: 0.01\r\n    value: 0.5 + sin(time) * 0.2\r\n  }\r\n\r\n  shader: shader {\r\n    code: \"precision highp float;\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\nuniform float power;\r\nuniform float speed;\r\n\r\nvarying vec2 uv;\r\n\r\nvec2 rotate(vec2 pos, float angle)\r\n{\r\n  float c = cos(angle);\r\n  float s = sin(angle);\r\n  return mat2(c, s, -s, c) * pos;\r\n}\r\n\r\nvoid main()\r\n{\r\n  vec2 uv2 = uv * (10.0 + sin(time * 0.3));\r\n  uv2 = rotate(uv2, sin(time * 0.2));\r\n  uv2 = abs(uv2);\r\n  uv2 = pow(uv2, vec2(power));\r\n  float value = cos(uv2.x * uv2.x + time * 3.7 * speed) + cos(uv2.y * uv2.y + time * speed);\r\n  vec3 color = vec3(value) + vec3(uv * 0.2 + 0.2, 0.0) * 2.0;\r\n  float alpha = 1.0;\r\n\r\n  gl_FragColor = vec4(color, alpha);\r\n}\r\n\"\r\n    uniforms: uniforms {\r\n      power: power_slider.value\r\n      speed: speed_slider.value\r\n    }\r\n  }\r\n\r\n  controls: controls {\r\n    item0: speed_slider\r\n    item1: power_slider\r\n  }\r\n}\r\n\r\nright_panel: shader_panel {\r\n  quantize_slider: ui.slider {\r\n    label: \"Quantize\"\r\n    min: 1\r\n    max: 100\r\n    step: 1\r\n    value: 1\r\n  }\r\n\r\n  shader: shader {\r\n    code: \"precision highp float;\r\n  \r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\nuniform float quantize;\r\n\r\nvarying vec2 uv;\r\n\r\nvoid main()\r\n{\r\n  //float quantize = sin(time) * 0.5 + 0.5;\r\n\r\n  float limit = max(resolution.x, resolution.y);\r\n  float step = limit / quantize;\r\n  vec2 uv2 = floor(uv * step) / step;\r\n\r\n  vec3 color = vec3(uv2 * 0.5 + 0.5, sin(time) * 0.5 + 0.5);\r\n  float alpha = float(abs(uv2.x - sin(uv2.y + time)) < 0.5);\r\n\r\n  gl_FragColor = vec4(color, alpha);\r\n}\r\n\"\r\n    uniforms: uniforms {\r\n      quantize: quantize_slider.value\r\n    }\r\n  }\r\n\r\n  controls: controls {\r\n    item0: quantize_slider\r\n  }\r\n}\r\n\r\nui: ui {\r\n  theme: default_themes.dark\r\n  page: ui.surface {\r\n    direction: \"column\"\r\n    color: \"primary\"\r\n    item0: ui.surface {\r\n      flex: 0\r\n      item0: ui.outline {}\r\n    }\r\n    item1: ui.surface {\r\n      direction: \"row\"\r\n      responsive: true\r\n      item0: left_panel\r\n      item1: right_panel\r\n    }\r\n  }\r\n}\r\n\r\n#>\r\n\r\nleft_panel: ui.surface {\r\n  color: \"background\"\r\n  elevation: -2\r\n  item0: ui.stack {\r\n    item0: plot.view {\r\n      viewport: viewport {\r\n        center: vec2(sin(time * 0.3) * 0.2, sin(time * 0.5)) * 0.3\r\n        size: vec2(6, 6)\r\n      }\r\n      item0: plot.grid {}\r\n      item1: plot.circle {\r\n        radius: 4 + sin(time) * 0.4\r\n        color: vec3(0.4, 0.4, 0.4)\r\n      }\r\n      item2: plot.circle {\r\n        radius: 3 + sin(time * 0.4) * 0.7\r\n        color: vec3(0.6, 0.4, 0.8)\r\n      }\r\n      item3: plot.circle {\r\n        radius: 2 + sin(time * 0.7) * 1.4\r\n        color: vec3(0.4, 0.1, 0.2)\r\n      }\r\n    }\r\n    item1: shader_panel {\r\n      color: \"none\"\r\n      elevation: 0\r\n      shader: shader {\r\n        code: \"precision highp float;\r\n  \r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\nuniform vec3 primary;\r\n\r\nvarying vec2 uv;\r\n\r\nfloat vmax(vec3 v)\r\n{\r\n  return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nvec2 rotate(vec2 uv, float angle)\r\n{\r\n  float c = cos(angle);\r\n  float s = sin(angle);\r\n  return mat2(c, s, -s, c) * uv;\r\n}\r\n\r\nfloat box(vec3 pos, vec3 size)\r\n{\r\n  vec3 offset = abs(pos) - size;\r\n  return length(max(offset, 0.0)) + min(vmax(offset), 0.0);\r\n}\r\n\r\nfloat map(vec3 pos)\r\n{\r\n  pos.xy = rotate(pos.xy, pos.z * sin(time * 2.0) * 0.4);\r\n\r\n  pos.xy = rotate(pos.xy, time);\r\n  pos.xz = rotate(pos.xz, time * 0.7);\r\n\r\n  return box(pos, vec3(1.0, 1.0, 2.0));\r\n}\r\n\r\nvec3 computeNormal(vec3 pos)\r\n{\r\n  vec2 eps = vec2(0.01, 0.0);\r\n  return normalize(vec3(\r\n    map(pos + eps.xyy) - map(pos - eps.xyy),\r\n    map(pos + eps.yxy) - map(pos - eps.yxy),\r\n    map(pos + eps.yyx) - map(pos - eps.yyx)\r\n  ));\r\n}\r\n\r\nvoid main()\r\n{\r\n  vec3 direction = normalize(vec3(uv, 1.0));\r\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n  vec3 pos = vec3(0.0, 0.0, -5.0);\r\n  for (int i = 0; i < 128; i++)\r\n  {\r\n    float d = map(pos);\r\n    if (d < 0.01)\r\n    {\r\n      vec3 normal = computeNormal(pos) * 0.5 + 0.5;\r\n      float diffuse = dot(normal, normalize(vec3(1.0)));\r\n\r\n      float alpha = exp(-pos.z * 0.1);\r\n      color = vec4(diffuse * primary, alpha);\r\n\r\n      break;\r\n    }\r\n    pos += d * direction;\r\n  }\r\n\r\n  gl_FragColor = color;\r\n}\r\n\"\r\n        uniforms: uniforms {\r\n          primary: ui.theme.colors.secondary\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"},{"name":"shader-editor","title":"Shader Editor","description":"Basic live shader editor","code":"\r\n\r\n\r\nui: ui {\r\n  theme: default_themes.dark\r\n  page: ui.surface {\r\n    direction: \"row\"\r\n    responsive: true\r\n    item0: ace.editor {\r\n      code: \"precision highp float;\r\n  \r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\nuniform vec3 primary;\r\n\r\nvarying vec2 uv;\r\n\r\nfloat vmax(vec3 v)\r\n{\r\n  return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nvec2 rotate(vec2 uv, float angle)\r\n{\r\n  float c = cos(angle);\r\n  float s = sin(angle);\r\n  return mat2(c, s, -s, c) * uv;\r\n}\r\n\r\nfloat box(vec3 pos, vec3 size)\r\n{\r\n  vec3 offset = abs(pos) - size;\r\n  return length(max(offset, 0.0)) + min(vmax(offset), 0.0);\r\n}\r\n\r\nfloat map(vec3 pos)\r\n{\r\n  pos.xy = rotate(pos.xy, pos.z * sin(time * 2.0) * 0.4);\r\n\r\n  pos.xy = rotate(pos.xy, time);\r\n  pos.xz = rotate(pos.xz, time * 0.7);\r\n\r\n  return box(pos, vec3(1.0, 1.0, 2.0));\r\n}\r\n\r\nvec3 computeNormal(vec3 pos)\r\n{\r\n  vec2 eps = vec2(0.01, 0.0);\r\n  return normalize(vec3(\r\n    map(pos + eps.xyy) - map(pos - eps.xyy),\r\n    map(pos + eps.yxy) - map(pos - eps.yxy),\r\n    map(pos + eps.yyx) - map(pos - eps.yyx)\r\n  ));\r\n}\r\n\r\nvoid main()\r\n{\r\n  vec3 direction = normalize(vec3(uv, 1.0));\r\n  vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\r\n\r\n  vec3 pos = vec3(0.0, 0.0, -5.0);\r\n  for (int i = 0; i < 128; i++)\r\n  {\r\n    float d = map(pos);\r\n    if (d < 0.01)\r\n    {\r\n      vec3 normal = computeNormal(pos) * 0.5 + 0.5;\r\n      float diffuse = dot(normal, normalize(vec3(1.0)));\r\n\r\n      float alpha = 1.0;\r\n      color = vec4(diffuse * primary, alpha);\r\n\r\n      break;\r\n    }\r\n    pos += d * direction;\r\n  }\r\n\r\n  gl_FragColor = color;\r\n}\r\n\"\r\n    }\r\n    item1: ui.shader {\r\n      code: item0.code\r\n      uniforms: {\r\n        primary: ui.theme.colors.primary\r\n        secondary: ui.theme.colors.secondary\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n#>\r\n\r\nui: ui {\r\n  page: page {\r\n    item0: item0 {\r\n      code: \"precision mediump float;\r\n\r\nuniform float time; // seconds\r\nvarying vec2 uv;\r\n\r\nfloat vmax(vec3 pos)\r\n{\r\n    return max(max(pos.x, pos.y), pos.z);\r\n}\r\n\r\nvec2 rotate(vec2 pos, float angle)\r\n{\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return mat2(c, s, -s, c) * pos;\r\n}\r\n\r\nfloat box(vec3 pos, vec3 size)\r\n{\r\n    vec3 off = abs(pos) - size;\r\n    return length(max(off, 0.0)) + vmax(min(off, 0.0));\r\n}\r\n\r\nfloat map(vec3 pos)\r\n{\r\n    vec3 period = vec3(6.0);\r\n    pos = mod(pos + 0.5 * period, period) - 0.5 * period;\r\n    \r\n    pos.xy = rotate(pos.xy, time * 0.2);\r\n    pos.xz = rotate(pos.xz, time * 0.7);\r\n\r\n    pos.xz = rotate(pos.xz, pos.y * 0.5);\r\n\r\n    return box(pos, vec3(0.6, 2.0, 0.6));\r\n}\r\n\r\nvec3 computeNormal(vec3 pos)\r\n{\r\n    vec2 eps = vec2(0.01, 0.0);\r\n    return normalize(vec3(\r\n        map(pos + eps.xyy) - map(pos - eps.xyy),\r\n        map(pos + eps.yxy) - map(pos - eps.yxy),\r\n        map(pos + eps.yyx) - map(pos - eps.yyx)\r\n    ));\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 cameraPosition = vec3(cos(time * 0.4) * 5.0, cos(time * 0.7) * 2.0, -3.0);\r\n    \r\n    vec3 pos = cameraPosition;\r\n    vec3 dir = normalize(vec3(uv, 1.0 - length(uv) * 0.4));\r\n    \r\n    dir.xy = rotate(dir.xy, time * 0.07);\r\n    dir.xz = rotate(dir.xz, time * 0.2);\r\n    \r\n    vec3 sky = mix(vec3(0.6, 0.7, 1.0), vec3(1.0, 0.9, 0.8), (uv.x + uv.y) * 0.7);\r\n    \r\n    vec3 color = sky;\r\n    for (int i = 0; i < 128; i++)\r\n    {\r\n        float d = map(pos);\r\n        if (d < 0.01)\r\n        {\r\n\t\t    color = computeNormal(pos) * 0.5 + 0.5;\r\n            break;\r\n        }\r\n        pos += dir * d * 0.4;\r\n    }\r\n    \r\n    float fog = exp(-distance(cameraPosition, pos) * 0.1);\r\n    color = mix(sky, color, fog);\r\n    \r\n    color = pow(color, vec3(1.0 / 2.2));\r\n    \r\n    // Output to screen\r\n\tgl_FragColor = vec4(color, 1.0);\r\n}\r\n\"\r\n    }\r\n  }\r\n}\r\n"},{"name":"widgets","title":"Widgets","description":"UI building blocks","code":"\r\n\r\n# dark_toggle: ui.toggle {\r\n#   label: \"Dark Mode\"\r\n# }\r\n\r\ndark_toggle: ui.slider {\r\n  label: \"Dark Mode\"\r\n  min: 0\r\n  max: 1\r\n  step: 1\r\n  value: 0\r\n}\r\n\r\nui: ui {\r\n  theme: if dark_toggle.value != 0 then default_themes.dark else default_themes.light\r\n}\r\n\r\nslider_template: ui.slider {\r\n  label: \"value = \" + str(value)\r\n}\r\n\r\n# Widgets demo\r\nui: ui {\r\n  page: ui.surface {\r\n    color: \"primary\"\r\n    item0: ui.surface {\r\n      direction: \"column\"\r\n      color: \"background\"\r\n      elevation: 2\r\n      item0: dark_toggle\r\n      item1: ui.textbox {\r\n        text: \"Welcome to the widgets demo!\r\n        \r\n        Multiline text kinda works, but in a fairly hacky way for now ;)\"\r\n      }\r\n      item2: ui.surface {\r\n        item0: slider_template {}\r\n        item1: slider_template {}\r\n        item2: slider_template {}\r\n        item3: slider_template {}\r\n      }\r\n      item3: ui.surface {\r\n        direction: \"column\"\r\n        flex: 2\r\n        item0: slider_template {}\r\n        item1: slider_template {}\r\n        item2: slider_template {}\r\n        item3: slider_template {}\r\n      }\r\n    }\r\n    item1: ui.surface {\r\n    }\r\n  }\r\n}\r\n"}],"background":{"name":"explore-background","title":"Background","description":"Hidden sample - menu background","code":"\r\n\r\nui: ui {\r\n  page: ui.shader {\r\n    code: \"precision highp float;\r\n\r\n//\n// GLSL textureless classic 3D noise 'cnoise',\n// with an RSL-style periodic variant 'pnoise'.\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\nvarying vec2 uv;\r\n\r\nvec2 rotate(vec2 pos, float angle)\r\n{\r\n  float c = cos(angle);\r\n  float s = sin(angle);\r\n  return mat2(c, s, -s, c) * pos;\r\n}\r\n\r\nfloat vmax(vec2 v)\r\n{\r\n  return max(v.x, v.y);\r\n}\r\n\r\nfloat fbm(vec2 pos)\r\n{\r\n  float value = 0.0;\r\n\r\n  float scale = 0.01;\r\n  float weight = 0.5;\r\n  for (int i = 0; i < 8; i++)\r\n  {\r\n    value += cnoise(vec3(pos * scale, time * 0.24 * weight)) * weight;\r\n    scale *= 1.7;\r\n    weight *= 0.7;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfloat box(vec2 uv, vec2 size)\r\n{\r\n  vec2 offset = abs(uv) - size;\r\n  return length(max(offset, 0.0)) + vmax(min(offset, 0.0));\r\n}\r\n\r\nfloat arrow(vec2 uv)\r\n{\r\n  uv.y -= 0.2;\r\n\r\n  float body = box(uv, vec2(0.2, 0.03));\r\n\r\n  uv.x += 0.2;\r\n\r\n  body = min(body, length(uv) - 0.03);\r\n\r\n  vec2 uv2 = rotate(uv, 0.7);\r\n  uv2.x -= 0.12;\r\n\r\n  body = min(body, box(uv2, vec2(0.12, 0.03)));\r\n\r\n  uv2 = rotate(uv, -0.7);\r\n  uv2.x -= 0.12;\r\n\r\n  body = min(body, box(uv2, vec2(0.12, 0.03)));\r\n\r\n  return body;\r\n}\r\n\r\nvoid main()\r\n{\r\n  float noise = fbm(gl_FragCoord.xy);\r\n  noise = noise * 0.5 + 0.5;\r\n\r\n  float threshold = smoothstep(noise + 0.2, noise - 0.2, gl_FragCoord.x / 256.0);\r\n\r\n  float arr = arrow(uv);\r\n  float arrowBorder = 0.01;\r\n  //arr += (noise - 0.5) * smoothstep(arrowBorder, -arrowBorder, arr) * smoothstep(-arrowBorder, arrowBorder, arr) * 10.8;\r\n  //arr = smoothstep(0.01, -0.01, arr);\r\n\r\n  arr = smoothstep(noise * 0.1, -noise * 0.1, arr);\r\n\r\n  threshold = max(threshold, arr);\r\n\r\n  threshold = pow(threshold, 4.0);\r\n\r\n  float fade = smoothstep(0.2, 0.4, noise) * 0.4 + 0.2;\r\n\r\n  vec3 color = vec3(8.0, 4.0, 3.0) / 255.0;\r\n  vec3 background = mix(vec3(0.9, 0.87, 0.8), vec3(1.0), uv.y - fade);\r\n\r\n  color = mix(background, color, threshold);\r\n\r\n  gl_FragColor = vec4(color, 1.0);\r\n}\r\n\"\r\n  }\r\n}\r\n"}},"path":"samples"}
