<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><link rel="preload" as="script" href="/templates/styles.e868749a.js"/><link rel="preload" as="script" href="/templates/vendors~main.31916a19.js"/><link rel="preload" as="script" href="/main.5ebfea21.js"/><link rel="preload" as="style" href="/styles.4ef69e58.css"/><link rel="stylesheet" href="/styles.4ef69e58.css"/></head><body><div id="root"><div style="outline:none" tabindex="-1"><nav><div class="start"><a class="logo" href="/"><img src="/images/logo.svg" alt="Smeli"/></a></div><div class="end"><a href="/">Home</a><a href="/about">About</a><a href="/samples">Samples</a></div></nav><div class="content"><div style="outline:none" tabindex="-1"></div></div><footer><p>Copyright (c) 2020-2022 Rémi Papillié (@wsmind)</p></footer></div></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/src/pages/samples\",\"sharedHashesByProp\":{},\"data\":{\"samples\":[{\"name\":\"layout\",\"title\":\"Layout\",\"description\":\"UI Layout Examples\",\"code\":\"\\r\\n\\r\\n# Layout demo\\r\\n### Move the slider!\\r\\n\\r\\nelevation_slider: ui.slider {\\r\\n  min: 1\\r\\n  max: 16\\r\\n  value: 4\\r\\n  label: \\\"Elevation\\\"\\r\\n}\\r\\n\\r\\nsize_slider: ui.slider {\\r\\n  min: 0\\r\\n  max: 4\\r\\n  step: 0.1\\r\\n  label: \\\"Size Variation\\\"\\r\\n}\\r\\n\\r\\ndemo: ui.surface {\\r\\n  direction: \\\"column\\\"\\r\\n  item0: ui.surface {\\r\\n    color: \\\"primary\\\"\\r\\n    elevation: elevation_slider.value\\r\\n    item0: ui.textbox {\\r\\n      text: str(elevation)\\r\\n    }\\r\\n  }\\r\\n  item1: ui.surface {\\r\\n    flex: size_slider.value\\r\\n    elevation: 0 - elevation_slider.value\\r\\n    color: \\\"secondary\\\"\\r\\n    item0: ui.textbox {\\r\\n      text: str(elevation)\\r\\n    }\\r\\n  }\\r\\n  item2: ui.surface {\\r\\n    elevation: elevation_slider.value\\r\\n    item0: ui.outline {}\\r\\n  }\\r\\n}\\r\\n\\r\\nui: ui {\\r\\n  page: ui.surface {\\r\\n    direction: \\\"row\\\"\\r\\n    responsive: true\\r\\n    item0: ui.surface {\\r\\n      direction: \\\"column\\\"\\r\\n      elevation: 16\\r\\n      item0: ui.outline {}\\r\\n      item1: ui.surface {\\r\\n        direction: \\\"column\\\"\\r\\n        flex: 0\\r\\n        item0: elevation_slider\\r\\n        item1: size_slider\\r\\n      }\\r\\n    }\\r\\n    item1: demo\\r\\n  }\\r\\n}\\r\\n\\r\\n##> Fading panels\\r\\nfading_panel: ui.surface {\\r\\n  fade: true\\r\\n  item0: ui.textbox {\\r\\n    text: str(elevation)\\r\\n  }\\r\\n}\\r\\n\\r\\ndemo: ui.surface {\\r\\n  direction: \\\"column\\\"\\r\\n  \\r\\n  item0: fading_panel {\\r\\n    flex: size_slider.value\\r\\n    color: \\\"primary\\\"\\r\\n    elevation: 0 - elevation_slider.value\\r\\n  }\\r\\n  item1: fading_panel {\\r\\n    color: \\\"secondary\\\"\\r\\n    elevation: elevation_slider.value\\r\\n  }\\r\\n  item2: fading_panel {\\r\\n    flex: 4 - size_slider.value\\r\\n    color: \\\"background\\\"\\r\\n    elevation: 0 - elevation_slider.value\\r\\n  }\\r\\n  item3: fading_panel {\\r\\n    color: \\\"secondary\\\"\\r\\n    elevation: elevation_slider.value\\r\\n  }\\r\\n}\\r\\n\\r\\n##> Flat style\\r\\nui: ui {\\r\\n  page: page {\\r\\n    item0: item0 {\\r\\n      elevation: 0\\r\\n      fade: true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ndemo: ui.surface {\\r\\n  direction: \\\"column\\\"\\r\\n  color: \\\"secondary\\\"\\r\\n  fade: true\\r\\n  item0: ui.surface {}\\r\\n  item1: ui.surface {\\r\\n    color: \\\"background\\\"\\r\\n    item0: ui.surface {\\r\\n      flex: (size_slider.value + 1) / 4\\r\\n      color: \\\"primary\\\"\\r\\n    }\\r\\n    item1: ui.surface {\\r\\n      direction: \\\"column\\\"\\r\\n      item0: ui.surface {\\r\\n        color: \\\"background\\\"\\r\\n      }\\r\\n      item1: ui.surface {\\r\\n        flex: size_slider.value\\r\\n        color: \\\"secondary\\\"\\r\\n      }\\r\\n      item2: ui.surface {\\r\\n        flex: 4 - size_slider.value\\r\\n        color: \\\"background\\\"\\r\\n      }\\r\\n      item3: ui.surface {\\r\\n        flex: size_slider.value * 2\\r\\n        color: \\\"secondary\\\"\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n##> Dark mode\\r\\nui: ui {\\r\\n  theme: default_themes.dark\\r\\n}\\r\\n\\r\\n###> Elevation light\\r\\nelevation_slider: elevation_slider {\\r\\n  value: 1\\r\\n}\\r\\n\\r\\nelevation_panel: fading_panel {\\r\\n  fade: false\\r\\n}\\r\\n\\r\\ndemo: ui.surface {\\r\\n  direction: \\\"column\\\"\\r\\n  fade: true\\r\\n  item0: ui.surface {\\r\\n    direction: \\\"column\\\"\\r\\n    item0: elevation_panel {\\r\\n      flex: size_slider.value\\r\\n      color: \\\"background\\\"\\r\\n      elevation: elevation_slider.value - 8\\r\\n    }\\r\\n    item1: elevation_panel {\\r\\n      color: \\\"background\\\"\\r\\n      elevation: elevation_slider.value - 4\\r\\n    }\\r\\n    item2: elevation_panel {\\r\\n      flex: 4 - size_slider.value\\r\\n      color: \\\"background\\\"\\r\\n      elevation: elevation_slider.value\\r\\n    }\\r\\n    item3: elevation_panel {\\r\\n      color: \\\"background\\\"\\r\\n      elevation: min(elevation_slider.value + 4, 16)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},{\"name\":\"plots\",\"title\":\"Plots\",\"description\":\"Graph toolkit\",\"code\":\"\\r\\n\\r\\n\\r\\nui: ui {\\r\\n  theme: default_themes.dark\\r\\n}\\r\\n\\r\\n# Plot Demo\\r\\n\\r\\nf: x => sin(x * sin(time)) * 0.4 - 2\\r\\n\\r\\neps: 0.01\\r\\nderive: func => x => (func(x + eps) - func(x - eps)) / (2 * eps)\\r\\n\\r\\ng: derive(f)\\r\\n\\r\\ndemo_plot: plot.view {\\r\\n  viewport: viewport {\\r\\n    center: vec2(sin(time), sin(time * 0.7))\\r\\n    size: vec2(8, 8)\\r\\n  }\\r\\n  item0: plot.grid {}\\r\\n  item1: plot.polygon {\\r\\n    point0: point0 + vec2(sin(time), 0)\\r\\n    point2: point2 + vec2(0, sin(time * 0.4))\\r\\n    point3: point2 + vec2(1, sin(time * 0.4))\\r\\n  }\\r\\n  item2: item1 {\\r\\n    color: ui.theme.colors.secondary\\r\\n    point1: point1 + vec2(0.5, 2.0)\\r\\n    point3: point3 - vec2(1, sin(time * 0.4))\\r\\n  }\\r\\n  item3: plot.angle {\\r\\n    point0: vec2(2.4 + cos(time), 2.2 + sin(time))\\r\\n    point1: vec2(2.4, 2.2)\\r\\n    point2: vec2(4.0, 2.4)\\r\\n    label: \\\"\u03B1\\\"\\r\\n  }\\r\\n  item4: plot.angle {\\r\\n    color: vec3(0.4, 0.8, 0.5)\\r\\n    point0: vec2(1.4 + cos(time * 0.2), 1 + sin(time * 0.72))\\r\\n    point1: vec2(1.4, 1)\\r\\n    point2: vec2(1.2, 0.2)\\r\\n    label: \\\"\u03B2\\\"\\r\\n  }\\r\\n  item5: plot.function {\\r\\n    function: f\\r\\n  }\\r\\n  item6: plot.point {\\r\\n    position: vec2(-2, item5.function(-2))\\r\\n    guides: true\\r\\n    label: \\\"f(-2)\\\"\\r\\n  }\\r\\n  item7: plot.function {\\r\\n    function: derive(item5.function)\\r\\n    color: vec3(0.4, 0.6, 0.8)\\r\\n  }\\r\\n  # item7: plot.circle {\\r\\n  #   color: item4.color\\r\\n  #   center: vec2(3, -2)\\r\\n  #   slice: slice * sin(time * 0.3) * 0.5 + slice * 0.5\\r\\n  # }\\r\\n  # item7: plot.vector {\\r\\n  #   color: vec3(0.4, 0.8, 0.9)\\r\\n  #   start: vec2(-4, 1)\\r\\n  #   end: start + vec2(cos(time), sin(time))\\r\\n  #   label: \\\"u\\\"\\r\\n  # }\\r\\n}\\r\\n\\r\\nui: ui {\\r\\n  page: ui.surface {\\r\\n    color: \\\"primary\\\"\\r\\n    direction: \\\"column\\\"\\r\\n    item0: ui.surface {\\r\\n      flex: 0\\r\\n      item0: ui.outline\\r\\n    }\\r\\n    item1: ui.surface {\\r\\n      color: \\\"background\\\"\\r\\n      elevation: -2\\r\\n      item0: demo_plot\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n#>\\r\\n\\r\\ndemo_plot: demo_plot {\\r\\n  viewport: viewport {\\r\\n    center: animate(center, center + vec2(4, 0), 0.5)\\r\\n    size: animate(size, size * 2, 0.5)\\r\\n  }\\r\\n\\r\\n  # item7: item7 {\\r\\n  #   start: animate(start, start + vec2(15, 0), 0.5)\\r\\n  # }\\r\\n\\r\\n  item5: item5 {\\r\\n    function: x => animate(f(x), x * x, 0.5)\\r\\n  }\\r\\n}\\r\\n\"},{\"name\":\"readme\",\"title\":\"README\",\"description\":\"Example from project README\",\"code\":\"\\r\\n\\r\\n\\r\\n\\r\\n# Switch to dark theme\\r\\nui: ui {\\r\\n  theme: default_themes.dark\\r\\n}\\r\\n\\r\\n# Let's start with a simple sine expression\\r\\nx: -0.4\\r\\nf: x => sin(1 - x)\\r\\n\\r\\nformula_panel: katex.formula {\\r\\n  code: katex.transpile(&f)\\r\\n}\\r\\n\\r\\nui: ui {\\r\\n  page: ui.stack {\\r\\n    item0: formula_panel\\r\\n    item1: ui.outline\\r\\n  }\\r\\n}\\r\\n\\r\\n#> Add a plot view\\r\\nf_plot: plot.view {\\r\\n  viewport: viewport {\\r\\n    size: vec2(4, 6)\\r\\n  }\\r\\n  item0: plot.grid {}\\r\\n  item1: plot.function {\\r\\n    function: f\\r\\n  }\\r\\n  item2: plot.point {\\r\\n    position: vec2(x, f(x))\\r\\n    label: \\\"(x, f(x))\\\"\\r\\n    color: ui.theme.colors.secondary * 1.2\\r\\n    guides: true\\r\\n  }\\r\\n}\\r\\n\\r\\nui: ui {\\r\\n  page: ui.surface {\\r\\n    direction: \\\"column\\\"\\r\\n    item0: ui.stack {\\r\\n      item0: ui.surface {\\r\\n        direction: \\\"column\\\"\\r\\n        elevation: -2\\r\\n        item0: f_plot\\r\\n      }\\r\\n      item1: ui.outline\\r\\n    }\\r\\n    item1: ui.surface {\\r\\n      flex: 0\\r\\n      item0: formula_panel\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n##> Add a slider to tweak the x value\\r\\nx_slider: ui.slider {\\r\\n  min: -1\\r\\n  max: 1\\r\\n  step: 0.01\\r\\n  value: x\\r\\n}\\r\\nx: x_slider.value\\r\\n\\r\\nui: ui {\\r\\n  page: page {\\r\\n    item2: ui.surface {\\r\\n      flex: 0\\r\\n      item0: x_slider\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n#> Now let's show another expression\\r\\nf: x => pow(x, 3)\\r\\n\"},{\"name\":\"shaders\",\"title\":\"Shaders\",\"description\":\"GLSL shaders embedding\",\"code\":\"\\r\\n\\r\\n\\r\\n# Shader demo\\r\\n\\r\\nshader_panel: ui.surface {\\r\\n  shader: ui.shader {}\\r\\n  controls: ui.surface {\\r\\n  }\\r\\n\\r\\n  direction: \\\"column\\\"\\r\\n  color: \\\"background\\\"\\r\\n  elevation: 2\\r\\n  fade: true\\r\\n  item0: shader\\r\\n  item1: ui.surface {\\r\\n    flex: 0\\r\\n    item0: controls\\r\\n  }\\r\\n}\\r\\n\\r\\nleft_panel: shader_panel {\\r\\n  speed_slider: ui.slider {\\r\\n    label: \\\"Speed\\\"\\r\\n    min: 1\\r\\n    max: 10\\r\\n    step: 0.01\\r\\n    value: 1\\r\\n  }\\r\\n\\r\\n  power_slider: ui.slider {\\r\\n    label: \\\"Power\\\"\\r\\n    min: 0.2\\r\\n    max: 1\\r\\n    step: 0.01\\r\\n    value: 0.5 + sin(time) * 0.2\\r\\n  }\\r\\n\\r\\n  shader: shader {\\r\\n    code: \\\"precision highp float;\\r\\n\\r\\nuniform float time;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nuniform float power;\\r\\nuniform float speed;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nvec2 rotate(vec2 pos, float angle)\\r\\n{\\r\\n  float c = cos(angle);\\r\\n  float s = sin(angle);\\r\\n  return mat2(c, s, -s, c) * pos;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n  vec2 uv2 = uv * (10.0 + sin(time * 0.3));\\r\\n  uv2 = rotate(uv2, sin(time * 0.2));\\r\\n  uv2 = abs(uv2);\\r\\n  uv2 = pow(uv2, vec2(power));\\r\\n  float value = cos(uv2.x * uv2.x + time * 3.7 * speed) + cos(uv2.y * uv2.y + time * speed);\\r\\n  vec3 color = vec3(value) + vec3(uv * 0.2 + 0.2, 0.0) * 2.0;\\r\\n  float alpha = 1.0;\\r\\n\\r\\n  gl_FragColor = vec4(color, alpha);\\r\\n}\\r\\n\\\"\\r\\n    uniforms: uniforms {\\r\\n      power: power_slider.value\\r\\n      speed: speed_slider.value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  controls: controls {\\r\\n    item0: speed_slider\\r\\n    item1: power_slider\\r\\n  }\\r\\n}\\r\\n\\r\\nright_panel: shader_panel {\\r\\n  quantize_slider: ui.slider {\\r\\n    label: \\\"Quantize\\\"\\r\\n    min: 1\\r\\n    max: 100\\r\\n    step: 1\\r\\n    value: 1\\r\\n  }\\r\\n\\r\\n  shader: shader {\\r\\n    code: \\\"precision highp float;\\r\\n  \\r\\nuniform float time;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nuniform float quantize;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n  //float quantize = sin(time) * 0.5 + 0.5;\\r\\n\\r\\n  float limit = max(resolution.x, resolution.y);\\r\\n  float step = limit / quantize;\\r\\n  vec2 uv2 = floor(uv * step) / step;\\r\\n\\r\\n  vec3 color = vec3(uv2 * 0.5 + 0.5, sin(time) * 0.5 + 0.5);\\r\\n  float alpha = float(abs(uv2.x - sin(uv2.y + time)) < 0.5);\\r\\n\\r\\n  gl_FragColor = vec4(color, alpha);\\r\\n}\\r\\n\\\"\\r\\n    uniforms: uniforms {\\r\\n      quantize: quantize_slider.value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  controls: controls {\\r\\n    item0: quantize_slider\\r\\n  }\\r\\n}\\r\\n\\r\\nui: ui {\\r\\n  theme: default_themes.dark\\r\\n  page: ui.surface {\\r\\n    direction: \\\"column\\\"\\r\\n    color: \\\"primary\\\"\\r\\n    item0: ui.surface {\\r\\n      flex: 0\\r\\n      item0: ui.outline {}\\r\\n    }\\r\\n    item1: ui.surface {\\r\\n      direction: \\\"row\\\"\\r\\n      responsive: true\\r\\n      item0: left_panel\\r\\n      item1: right_panel\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n#>\\r\\n\\r\\nleft_panel: ui.surface {\\r\\n  color: \\\"background\\\"\\r\\n  elevation: -2\\r\\n  item0: ui.stack {\\r\\n    item0: plot.view {\\r\\n      viewport: viewport {\\r\\n        center: vec2(sin(time * 0.3) * 0.2, sin(time * 0.5)) * 0.3\\r\\n        size: vec2(6, 6)\\r\\n      }\\r\\n      item0: plot.grid {}\\r\\n      item1: plot.circle {\\r\\n        radius: 4 + sin(time) * 0.4\\r\\n        color: vec3(0.4, 0.4, 0.4)\\r\\n      }\\r\\n      item2: plot.circle {\\r\\n        radius: 3 + sin(time * 0.4) * 0.7\\r\\n        color: vec3(0.6, 0.4, 0.8)\\r\\n      }\\r\\n      item3: plot.circle {\\r\\n        radius: 2 + sin(time * 0.7) * 1.4\\r\\n        color: vec3(0.4, 0.1, 0.2)\\r\\n      }\\r\\n    }\\r\\n    item1: shader_panel {\\r\\n      color: \\\"none\\\"\\r\\n      elevation: 0\\r\\n      shader: shader {\\r\\n        code: \\\"precision highp float;\\r\\n  \\r\\nuniform float time;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nuniform vec3 primary;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nfloat vmax(vec3 v)\\r\\n{\\r\\n  return max(max(v.x, v.y), v.z);\\r\\n}\\r\\n\\r\\nvec2 rotate(vec2 uv, float angle)\\r\\n{\\r\\n  float c = cos(angle);\\r\\n  float s = sin(angle);\\r\\n  return mat2(c, s, -s, c) * uv;\\r\\n}\\r\\n\\r\\nfloat box(vec3 pos, vec3 size)\\r\\n{\\r\\n  vec3 offset = abs(pos) - size;\\r\\n  return length(max(offset, 0.0)) + min(vmax(offset), 0.0);\\r\\n}\\r\\n\\r\\nfloat map(vec3 pos)\\r\\n{\\r\\n  pos.xy = rotate(pos.xy, pos.z * sin(time * 2.0) * 0.4);\\r\\n\\r\\n  pos.xy = rotate(pos.xy, time);\\r\\n  pos.xz = rotate(pos.xz, time * 0.7);\\r\\n\\r\\n  return box(pos, vec3(1.0, 1.0, 2.0));\\r\\n}\\r\\n\\r\\nvec3 computeNormal(vec3 pos)\\r\\n{\\r\\n  vec2 eps = vec2(0.01, 0.0);\\r\\n  return normalize(vec3(\\r\\n    map(pos + eps.xyy) - map(pos - eps.xyy),\\r\\n    map(pos + eps.yxy) - map(pos - eps.yxy),\\r\\n    map(pos + eps.yyx) - map(pos - eps.yyx)\\r\\n  ));\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n  vec3 direction = normalize(vec3(uv, 1.0));\\r\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n\\r\\n  vec3 pos = vec3(0.0, 0.0, -5.0);\\r\\n  for (int i = 0; i < 128; i++)\\r\\n  {\\r\\n    float d = map(pos);\\r\\n    if (d < 0.01)\\r\\n    {\\r\\n      vec3 normal = computeNormal(pos) * 0.5 + 0.5;\\r\\n      float diffuse = dot(normal, normalize(vec3(1.0)));\\r\\n\\r\\n      float alpha = exp(-pos.z * 0.1);\\r\\n      color = vec4(diffuse * primary, alpha);\\r\\n\\r\\n      break;\\r\\n    }\\r\\n    pos += d * direction;\\r\\n  }\\r\\n\\r\\n  gl_FragColor = color;\\r\\n}\\r\\n\\\"\\r\\n        uniforms: uniforms {\\r\\n          primary: ui.theme.colors.secondary\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},{\"name\":\"shader-editor\",\"title\":\"Shader Editor\",\"description\":\"Basic live shader editor\",\"code\":\"\\r\\n\\r\\n\\r\\nui: ui {\\r\\n  theme: default_themes.dark\\r\\n  page: ui.surface {\\r\\n    direction: \\\"row\\\"\\r\\n    responsive: true\\r\\n    item0: ace.editor {\\r\\n      code: \\\"precision highp float;\\r\\n  \\r\\nuniform float time;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nuniform vec3 primary;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nfloat vmax(vec3 v)\\r\\n{\\r\\n  return max(max(v.x, v.y), v.z);\\r\\n}\\r\\n\\r\\nvec2 rotate(vec2 uv, float angle)\\r\\n{\\r\\n  float c = cos(angle);\\r\\n  float s = sin(angle);\\r\\n  return mat2(c, s, -s, c) * uv;\\r\\n}\\r\\n\\r\\nfloat box(vec3 pos, vec3 size)\\r\\n{\\r\\n  vec3 offset = abs(pos) - size;\\r\\n  return length(max(offset, 0.0)) + min(vmax(offset), 0.0);\\r\\n}\\r\\n\\r\\nfloat map(vec3 pos)\\r\\n{\\r\\n  pos.xy = rotate(pos.xy, pos.z * sin(time * 2.0) * 0.4);\\r\\n\\r\\n  pos.xy = rotate(pos.xy, time);\\r\\n  pos.xz = rotate(pos.xz, time * 0.7);\\r\\n\\r\\n  return box(pos, vec3(1.0, 1.0, 2.0));\\r\\n}\\r\\n\\r\\nvec3 computeNormal(vec3 pos)\\r\\n{\\r\\n  vec2 eps = vec2(0.01, 0.0);\\r\\n  return normalize(vec3(\\r\\n    map(pos + eps.xyy) - map(pos - eps.xyy),\\r\\n    map(pos + eps.yxy) - map(pos - eps.yxy),\\r\\n    map(pos + eps.yyx) - map(pos - eps.yyx)\\r\\n  ));\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n  vec3 direction = normalize(vec3(uv, 1.0));\\r\\n  vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\\r\\n\\r\\n  vec3 pos = vec3(0.0, 0.0, -5.0);\\r\\n  for (int i = 0; i < 128; i++)\\r\\n  {\\r\\n    float d = map(pos);\\r\\n    if (d < 0.01)\\r\\n    {\\r\\n      vec3 normal = computeNormal(pos) * 0.5 + 0.5;\\r\\n      float diffuse = dot(normal, normalize(vec3(1.0)));\\r\\n\\r\\n      float alpha = 1.0;\\r\\n      color = vec4(diffuse * primary, alpha);\\r\\n\\r\\n      break;\\r\\n    }\\r\\n    pos += d * direction;\\r\\n  }\\r\\n\\r\\n  gl_FragColor = color;\\r\\n}\\r\\n\\\"\\r\\n    }\\r\\n    item1: ui.shader {\\r\\n      code: item0.code\\r\\n      uniforms: {\\r\\n        primary: ui.theme.colors.primary\\r\\n        secondary: ui.theme.colors.secondary\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n#>\\r\\n\\r\\nui: ui {\\r\\n  page: page {\\r\\n    item0: item0 {\\r\\n      code: \\\"precision mediump float;\\r\\n\\r\\nuniform float time; // seconds\\r\\nvarying vec2 uv;\\r\\n\\r\\nfloat vmax(vec3 pos)\\r\\n{\\r\\n    return max(max(pos.x, pos.y), pos.z);\\r\\n}\\r\\n\\r\\nvec2 rotate(vec2 pos, float angle)\\r\\n{\\r\\n    float c = cos(angle);\\r\\n    float s = sin(angle);\\r\\n    return mat2(c, s, -s, c) * pos;\\r\\n}\\r\\n\\r\\nfloat box(vec3 pos, vec3 size)\\r\\n{\\r\\n    vec3 off = abs(pos) - size;\\r\\n    return length(max(off, 0.0)) + vmax(min(off, 0.0));\\r\\n}\\r\\n\\r\\nfloat map(vec3 pos)\\r\\n{\\r\\n    vec3 period = vec3(6.0);\\r\\n    pos = mod(pos + 0.5 * period, period) - 0.5 * period;\\r\\n    \\r\\n    pos.xy = rotate(pos.xy, time * 0.2);\\r\\n    pos.xz = rotate(pos.xz, time * 0.7);\\r\\n\\r\\n    pos.xz = rotate(pos.xz, pos.y * 0.5);\\r\\n\\r\\n    return box(pos, vec3(0.6, 2.0, 0.6));\\r\\n}\\r\\n\\r\\nvec3 computeNormal(vec3 pos)\\r\\n{\\r\\n    vec2 eps = vec2(0.01, 0.0);\\r\\n    return normalize(vec3(\\r\\n        map(pos + eps.xyy) - map(pos - eps.xyy),\\r\\n        map(pos + eps.yxy) - map(pos - eps.yxy),\\r\\n        map(pos + eps.yyx) - map(pos - eps.yyx)\\r\\n    ));\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    vec3 cameraPosition = vec3(cos(time * 0.4) * 5.0, cos(time * 0.7) * 2.0, -3.0);\\r\\n    \\r\\n    vec3 pos = cameraPosition;\\r\\n    vec3 dir = normalize(vec3(uv, 1.0 - length(uv) * 0.4));\\r\\n    \\r\\n    dir.xy = rotate(dir.xy, time * 0.07);\\r\\n    dir.xz = rotate(dir.xz, time * 0.2);\\r\\n    \\r\\n    vec3 sky = mix(vec3(0.6, 0.7, 1.0), vec3(1.0, 0.9, 0.8), (uv.x + uv.y) * 0.7);\\r\\n    \\r\\n    vec3 color = sky;\\r\\n    for (int i = 0; i < 128; i++)\\r\\n    {\\r\\n        float d = map(pos);\\r\\n        if (d < 0.01)\\r\\n        {\\r\\n\\t\\t    color = computeNormal(pos) * 0.5 + 0.5;\\r\\n            break;\\r\\n        }\\r\\n        pos += dir * d * 0.4;\\r\\n    }\\r\\n    \\r\\n    float fog = exp(-distance(cameraPosition, pos) * 0.1);\\r\\n    color = mix(sky, color, fog);\\r\\n    \\r\\n    color = pow(color, vec3(1.0 / 2.2));\\r\\n    \\r\\n    // Output to screen\\r\\n\\tgl_FragColor = vec4(color, 1.0);\\r\\n}\\r\\n\\\"\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"},{\"name\":\"widgets\",\"title\":\"Widgets\",\"description\":\"UI building blocks\",\"code\":\"\\r\\n\\r\\n# dark_toggle: ui.toggle {\\r\\n#   label: \\\"Dark Mode\\\"\\r\\n# }\\r\\n\\r\\ndark_toggle: ui.slider {\\r\\n  label: \\\"Dark Mode\\\"\\r\\n  min: 0\\r\\n  max: 1\\r\\n  step: 1\\r\\n  value: 0\\r\\n}\\r\\n\\r\\nui: ui {\\r\\n  theme: if dark_toggle.value != 0 then default_themes.dark else default_themes.light\\r\\n}\\r\\n\\r\\nslider_template: ui.slider {\\r\\n  label: \\\"value = \\\" + str(value)\\r\\n}\\r\\n\\r\\n# Widgets demo\\r\\nui: ui {\\r\\n  page: ui.surface {\\r\\n    color: \\\"primary\\\"\\r\\n    item0: ui.surface {\\r\\n      direction: \\\"column\\\"\\r\\n      color: \\\"background\\\"\\r\\n      elevation: 2\\r\\n      item0: dark_toggle\\r\\n      item1: ui.textbox {\\r\\n        text: \\\"Welcome to the widgets demo!\\r\\n        \\r\\n        Multiline text kinda works, but in a fairly hacky way for now ;)\\\"\\r\\n      }\\r\\n      item2: ui.surface {\\r\\n        item0: slider_template {}\\r\\n        item1: slider_template {}\\r\\n        item2: slider_template {}\\r\\n        item3: slider_template {}\\r\\n      }\\r\\n      item3: ui.surface {\\r\\n        direction: \\\"column\\\"\\r\\n        flex: 2\\r\\n        item0: slider_template {}\\r\\n        item1: slider_template {}\\r\\n        item2: slider_template {}\\r\\n        item3: slider_template {}\\r\\n      }\\r\\n    }\\r\\n    item1: ui.surface {\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"}],\"currentSample\":{\"name\":\"shaders\",\"title\":\"Shaders\",\"description\":\"GLSL shaders embedding\",\"code\":\"\\r\\n\\r\\n\\r\\n# Shader demo\\r\\n\\r\\nshader_panel: ui.surface {\\r\\n  shader: ui.shader {}\\r\\n  controls: ui.surface {\\r\\n  }\\r\\n\\r\\n  direction: \\\"column\\\"\\r\\n  color: \\\"background\\\"\\r\\n  elevation: 2\\r\\n  fade: true\\r\\n  item0: shader\\r\\n  item1: ui.surface {\\r\\n    flex: 0\\r\\n    item0: controls\\r\\n  }\\r\\n}\\r\\n\\r\\nleft_panel: shader_panel {\\r\\n  speed_slider: ui.slider {\\r\\n    label: \\\"Speed\\\"\\r\\n    min: 1\\r\\n    max: 10\\r\\n    step: 0.01\\r\\n    value: 1\\r\\n  }\\r\\n\\r\\n  power_slider: ui.slider {\\r\\n    label: \\\"Power\\\"\\r\\n    min: 0.2\\r\\n    max: 1\\r\\n    step: 0.01\\r\\n    value: 0.5 + sin(time) * 0.2\\r\\n  }\\r\\n\\r\\n  shader: shader {\\r\\n    code: \\\"precision highp float;\\r\\n\\r\\nuniform float time;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nuniform float power;\\r\\nuniform float speed;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nvec2 rotate(vec2 pos, float angle)\\r\\n{\\r\\n  float c = cos(angle);\\r\\n  float s = sin(angle);\\r\\n  return mat2(c, s, -s, c) * pos;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n  vec2 uv2 = uv * (10.0 + sin(time * 0.3));\\r\\n  uv2 = rotate(uv2, sin(time * 0.2));\\r\\n  uv2 = abs(uv2);\\r\\n  uv2 = pow(uv2, vec2(power));\\r\\n  float value = cos(uv2.x * uv2.x + time * 3.7 * speed) + cos(uv2.y * uv2.y + time * speed);\\r\\n  vec3 color = vec3(value) + vec3(uv * 0.2 + 0.2, 0.0) * 2.0;\\r\\n  float alpha = 1.0;\\r\\n\\r\\n  gl_FragColor = vec4(color, alpha);\\r\\n}\\r\\n\\\"\\r\\n    uniforms: uniforms {\\r\\n      power: power_slider.value\\r\\n      speed: speed_slider.value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  controls: controls {\\r\\n    item0: speed_slider\\r\\n    item1: power_slider\\r\\n  }\\r\\n}\\r\\n\\r\\nright_panel: shader_panel {\\r\\n  quantize_slider: ui.slider {\\r\\n    label: \\\"Quantize\\\"\\r\\n    min: 1\\r\\n    max: 100\\r\\n    step: 1\\r\\n    value: 1\\r\\n  }\\r\\n\\r\\n  shader: shader {\\r\\n    code: \\\"precision highp float;\\r\\n  \\r\\nuniform float time;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nuniform float quantize;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n  //float quantize = sin(time) * 0.5 + 0.5;\\r\\n\\r\\n  float limit = max(resolution.x, resolution.y);\\r\\n  float step = limit / quantize;\\r\\n  vec2 uv2 = floor(uv * step) / step;\\r\\n\\r\\n  vec3 color = vec3(uv2 * 0.5 + 0.5, sin(time) * 0.5 + 0.5);\\r\\n  float alpha = float(abs(uv2.x - sin(uv2.y + time)) < 0.5);\\r\\n\\r\\n  gl_FragColor = vec4(color, alpha);\\r\\n}\\r\\n\\\"\\r\\n    uniforms: uniforms {\\r\\n      quantize: quantize_slider.value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  controls: controls {\\r\\n    item0: quantize_slider\\r\\n  }\\r\\n}\\r\\n\\r\\nui: ui {\\r\\n  theme: default_themes.dark\\r\\n  page: ui.surface {\\r\\n    direction: \\\"column\\\"\\r\\n    color: \\\"primary\\\"\\r\\n    item0: ui.surface {\\r\\n      flex: 0\\r\\n      item0: ui.outline {}\\r\\n    }\\r\\n    item1: ui.surface {\\r\\n      direction: \\\"row\\\"\\r\\n      responsive: true\\r\\n      item0: left_panel\\r\\n      item1: right_panel\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n#>\\r\\n\\r\\nleft_panel: ui.surface {\\r\\n  color: \\\"background\\\"\\r\\n  elevation: -2\\r\\n  item0: ui.stack {\\r\\n    item0: plot.view {\\r\\n      viewport: viewport {\\r\\n        center: vec2(sin(time * 0.3) * 0.2, sin(time * 0.5)) * 0.3\\r\\n        size: vec2(6, 6)\\r\\n      }\\r\\n      item0: plot.grid {}\\r\\n      item1: plot.circle {\\r\\n        radius: 4 + sin(time) * 0.4\\r\\n        color: vec3(0.4, 0.4, 0.4)\\r\\n      }\\r\\n      item2: plot.circle {\\r\\n        radius: 3 + sin(time * 0.4) * 0.7\\r\\n        color: vec3(0.6, 0.4, 0.8)\\r\\n      }\\r\\n      item3: plot.circle {\\r\\n        radius: 2 + sin(time * 0.7) * 1.4\\r\\n        color: vec3(0.4, 0.1, 0.2)\\r\\n      }\\r\\n    }\\r\\n    item1: shader_panel {\\r\\n      color: \\\"none\\\"\\r\\n      elevation: 0\\r\\n      shader: shader {\\r\\n        code: \\\"precision highp float;\\r\\n  \\r\\nuniform float time;\\r\\nuniform vec2 resolution;\\r\\n\\r\\nuniform vec3 primary;\\r\\n\\r\\nvarying vec2 uv;\\r\\n\\r\\nfloat vmax(vec3 v)\\r\\n{\\r\\n  return max(max(v.x, v.y), v.z);\\r\\n}\\r\\n\\r\\nvec2 rotate(vec2 uv, float angle)\\r\\n{\\r\\n  float c = cos(angle);\\r\\n  float s = sin(angle);\\r\\n  return mat2(c, s, -s, c) * uv;\\r\\n}\\r\\n\\r\\nfloat box(vec3 pos, vec3 size)\\r\\n{\\r\\n  vec3 offset = abs(pos) - size;\\r\\n  return length(max(offset, 0.0)) + min(vmax(offset), 0.0);\\r\\n}\\r\\n\\r\\nfloat map(vec3 pos)\\r\\n{\\r\\n  pos.xy = rotate(pos.xy, pos.z * sin(time * 2.0) * 0.4);\\r\\n\\r\\n  pos.xy = rotate(pos.xy, time);\\r\\n  pos.xz = rotate(pos.xz, time * 0.7);\\r\\n\\r\\n  return box(pos, vec3(1.0, 1.0, 2.0));\\r\\n}\\r\\n\\r\\nvec3 computeNormal(vec3 pos)\\r\\n{\\r\\n  vec2 eps = vec2(0.01, 0.0);\\r\\n  return normalize(vec3(\\r\\n    map(pos + eps.xyy) - map(pos - eps.xyy),\\r\\n    map(pos + eps.yxy) - map(pos - eps.yxy),\\r\\n    map(pos + eps.yyx) - map(pos - eps.yyx)\\r\\n  ));\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n  vec3 direction = normalize(vec3(uv, 1.0));\\r\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n\\r\\n  vec3 pos = vec3(0.0, 0.0, -5.0);\\r\\n  for (int i = 0; i < 128; i++)\\r\\n  {\\r\\n    float d = map(pos);\\r\\n    if (d < 0.01)\\r\\n    {\\r\\n      vec3 normal = computeNormal(pos) * 0.5 + 0.5;\\r\\n      float diffuse = dot(normal, normalize(vec3(1.0)));\\r\\n\\r\\n      float alpha = exp(-pos.z * 0.1);\\r\\n      color = vec4(diffuse * primary, alpha);\\r\\n\\r\\n      break;\\r\\n    }\\r\\n    pos += d * direction;\\r\\n  }\\r\\n\\r\\n  gl_FragColor = color;\\r\\n}\\r\\n\\\"\\r\\n        uniforms: uniforms {\\r\\n          primary: ui.theme.colors.secondary\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"}},\"path\":\"samples/shaders\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/styles.e868749a.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.31916a19.js"></script><script defer="" type="text/javascript" src="/main.5ebfea21.js"></script></body></html>